---
layout: post
title: Week Of March 7, 2016
---

This week, I got started on the Allocator project by partnering up with someone and abstracting the code I'm going to use for the project. The allocator doesn't look too difficult compared to the last project given a few over simplifications in the heap design I'm going to talk about later. I also got to hear a Rackspace employee talk about his company culture and various tools he uses in his work.

I have nothing in my way over Spring Break other than some projects for other classes in addition to a personal project. I'll just have to balance out my work and not focus too much on one thing.

Next week, I'll have to get started on writing out the code for Allocator. I already have an algorithm flow chart detailing how the algorithm will work for the allocator, so all I have to do is implement it. This time around I'll write my unit tests early so I can actually use them for proper debugging.

In class, I've been kind of confused at the simplicity of the allocator we're creating. The algorithm that we're taught in class doesn't really account for data blocks that are stuck in the middle of the heap and prevent data blocks that should fit from fitting because the free space is split up. Professor Downing cleared up that this is a simplified heap in class, but I still wonder how a proper heap would be implemented. My guess would be that on ever call to free, the heap should be shifted downward so that all free space is at the top of the heap. As for the engineer from Rackspace, I liked his talk but I question a lot of the corporate culture semantics like wearing your strengths and weaknesses on your badge. I've heard it works well for some people, but I've also heard horror stories from project managers and lead developers about how Agile development and its cultural derivatives were cultlike and how their team got a lot more work done when they were left more to their own devices, instead of having to strictly follow sprints and scrum meetings and whatnot. I guess it's about balance in the end, software developers tend to be introverted so too much social pressure could lead to more stress if it isn't handled correctly, and in my experience too much of a hive mentality can corrode one's ego, which sounds good in theory but for many developers including myself, pride in individual work is one of the biggest motivational factors in the workplace. It's hard to explain, but constant meetings and too much collaboration have a demoralizing effect for me. I feel like the strengths and weaknesses nametag is similar in that regard. Sure, people have weaknesses that they need to communicate and be aware of, but if you literally wear your weaknesses as a label, you'll never improve on them. I wasn't very good with version control some time ago, and thank God nobody made me wear that on my nametag because with a little elbow grease I've become pretty good at it and I feel like if I had to just embrace that as part of who I am I would have just given up on it.

Tip Of The Week: In an application that revolves around 3D rendering, such as a game engine, an OpenGL application, or a 3D framework, a lot of amateur developers like to set "boundaries" for object positioning, i.e. not being able to move past an invisible wall in a game, by clamping the position of the object after or as it has already travelled past the boundary in 3D space, and this causes a LOT of stuttering and ugliness. Recently, I've found that storing transform data as a separate variable, adjusting it and applying all transformations to the temp variable, and THEN actually applying the transformation to the object with a set resolves this issue, as it causes the program to think about what it's doing before the frame rendering is queued. 
